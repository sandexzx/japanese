<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonogram Solver Pro</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #f39c12;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .controls {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .controls label {
            margin-right: 10px;
        }

        .controls input {
            width: 60px;
            padding: 5px;
            margin-right: 20px;
            border: none;
            border-radius: 5px;
            background: #0f3460;
            color: #fff;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #e94560;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #gameContainer {
            position: relative;
            display: inline-block;
            background: #0f3460;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        table {
            border-collapse: collapse;
        }

        td {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
            text-align: center;
            position: relative;
            font-size: 12px;
            user-select: none;
        }

        .hint-cell {
            background: #16213e;
            color: #f39c12;
            font-weight: bold;
        }

        .hint-cell input {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            color: #f39c12;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .game-cell {
            background: #2d2d44;
            cursor: pointer;
            transition: all 0.2s;
        }

        .game-cell:hover {
            background: #3d3d54;
        }

        .filled {
            background: #27ae60 !important;
        }

        .crossed {
            background: #2d2d44;
        }

        .crossed::before,
        .crossed::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 2px;
            background: #e74c3c;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
        }

        .crossed::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }

        .highlight-row {
            background: #f39c12 !important;
            opacity: 0.3;
        }

        .hint-possible {
            background: #e67e22 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 10px;
            text-align: center;
        }

        .highlight-guaranteed-fill {
            animation: pulse-green 2s;
            background: #f1c40f !important;
        }
        
        .highlight-guaranteed-cross {
            animation: pulse-red 2s;
            background: #e74c3c !important;
        }
        
        @keyframes pulse-green {
            0% { background: #2d2d44; }
            50% { background: #f1c40f; }
            100% { background: #2d2d44; }
        }
        
        @keyframes pulse-red {
            0% { background: #2d2d44; }
            50% { background: #e74c3c; }
            100% { background: #2d2d44; }
        }
        
        .solver-info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #16213e;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .solver-info h3 {
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #0f3460;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #f39c12);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>üéÆ Nonogram Solver Pro üéÆ</h1>
    
    <div class="controls">
        <label>–®–∏—Ä–∏–Ω–∞:</label>
        <input type="number" id="width" value="10" min="5" max="30">
        <label>–í—ã—Å–æ—Ç–∞:</label>
        <input type="number" id="height" value="10" min="5" max="30">
        <button onclick="createGrid()">–°–æ–∑–¥–∞—Ç—å –ø–æ–ª–µ</button>
        <button onclick="checkPossibleLines()">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ª–∏–Ω–∏–∏</button>
        <button onclick="showHints()">üîç –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
        <button onclick="solveStep()">üìê –®–∞–≥ —Ä–µ—à–µ–Ω–∏—è</button>
        <button onclick="solveFull()">üöÄ –†–µ—à–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é</button>
        <button onclick="clearGrid()">–û—á–∏—Å—Ç–∏—Ç—å</button>
    </div>

    <div id="gameContainer"></div>
    
    <div class="solver-info" id="solverInfo">
        <h3>üß† –õ–æ–≥–∏–∫–∞ —Ä–µ—à–µ–Ω–∏—è</h3>
        <div id="solverMessage"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <div class="stats">
        <div id="statsInfo"></div>
        <div class="legend">
            –õ–ö–ú - –∑–∞–∫—Ä–∞—Å–∏—Ç—å | –ü–ö–ú - –∫—Ä–µ—Å—Ç–∏–∫ | –°—Ç—Ä–µ–ª–∫–∏ - –Ω–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º | –û—Ä–∞–Ω–∂–µ–≤—ã–µ —Å—Ç—Ä–æ–∫–∏ - –º–æ–∂–Ω–æ —á—Ç–æ-—Ç–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å
        </div>
    </div>

    <script>
        let grid = [];
        let topHints = [];
        let leftHints = [];
        let width = 10;
        let height = 10;
        let currentFocusedInput = null;

        function createGrid() {
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);
            
            const container = document.getElementById('gameContainer');
            container.innerHTML = '';
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—Å—Å–∏–≤–æ–≤
            grid = Array(height).fill().map(() => Array(width).fill(0));
            topHints = Array(width).fill().map(() => []);
            leftHints = Array(height).fill().map(() => []);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã
            const table = document.createElement('table');
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥—Å–∫–∞–∑–æ–∫
            const maxTopHints = Math.ceil(height / 2);
            const maxLeftHints = Math.ceil(width / 2);
            
            // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –≤–µ—Ä—Ö–Ω–∏—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫
            for (let i = 0; i < maxTopHints; i++) {
                const row = table.insertRow();
                
                // –ü—É—Å—Ç—ã–µ —è—á–µ–π–∫–∏ —Å–ª–µ–≤–∞
                for (let j = 0; j < maxLeftHints; j++) {
                    const cell = row.insertCell();
                    cell.className = 'hint-cell';
                }
                
                // –Ø—á–µ–π–∫–∏ –¥–ª—è –ø–æ–¥—Å–∫–∞–∑–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤
                for (let j = 0; j < width; j++) {
                    const cell = row.insertCell();
                    cell.className = 'hint-cell';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.dataset.col = j;
                    input.dataset.hintRow = i;
                    input.onchange = updateTopHint;
                    input.onfocus = () => currentFocusedInput = input;
                    input.onkeydown = handleHintKeyDown;
                    cell.appendChild(input);
                }
            }
            
            // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
            for (let i = 0; i < height; i++) {
                const row = table.insertRow();
                
                // –Ø—á–µ–π–∫–∏ –¥–ª—è –ª–µ–≤—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫
                for (let j = 0; j < maxLeftHints; j++) {
                    const cell = row.insertCell();
                    cell.className = 'hint-cell';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.dataset.row = i;
                    input.dataset.hintCol = j;
                    input.onchange = updateLeftHint;
                    input.onfocus = () => currentFocusedInput = input;
                    input.onkeydown = handleHintKeyDown;
                    cell.appendChild(input);
                }
                
                // –ò–≥—Ä–æ–≤—ã–µ —è—á–µ–π–∫–∏
                for (let j = 0; j < width; j++) {
                    const cell = row.insertCell();
                    cell.className = 'game-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.onclick = handleCellClick;
                    cell.oncontextmenu = handleRightClick;
                }
            }
            
            container.appendChild(table);
            updateStats();
        }

        function updateTopHint(e) {
            const col = parseInt(e.target.dataset.col);
            const hintRow = parseInt(e.target.dataset.hintRow);
            const value = e.target.value.trim();
            
            if (!topHints[col]) topHints[col] = [];
            
            if (value) {
                topHints[col][hintRow] = parseInt(value);
            } else {
                topHints[col][hintRow] = null;
            }
            
            // –£–±–∏—Ä–∞–µ–º null –∑–Ω–∞—á–µ–Ω–∏—è
            topHints[col] = topHints[col].filter(h => h !== null);
        }

        function updateLeftHint(e) {
            const row = parseInt(e.target.dataset.row);
            const hintCol = parseInt(e.target.dataset.hintCol);
            const value = e.target.value.trim();
            
            if (!leftHints[row]) leftHints[row] = [];
            
            if (value) {
                leftHints[row][hintCol] = parseInt(value);
            } else {
                leftHints[row][hintCol] = null;
            }
            
            // –£–±–∏—Ä–∞–µ–º null –∑–Ω–∞—á–µ–Ω–∏—è
            leftHints[row] = leftHints[row].filter(h => h !== null);
        }

        function handleCellClick(e) {
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            
            if (grid[row][col] === 1) {
                grid[row][col] = 0;
                e.target.classList.remove('filled');
            } else {
                grid[row][col] = 1;
                e.target.classList.add('filled');
                e.target.classList.remove('crossed');
            }
            
            updateStats();
        }

        function handleRightClick(e) {
            e.preventDefault();
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            
            if (e.target.classList.contains('crossed')) {
                grid[row][col] = 0;
                e.target.classList.remove('crossed');
            } else {
                grid[row][col] = -1;
                e.target.classList.add('crossed');
                e.target.classList.remove('filled');
            }
            
            updateStats();
        }

        function checkPossibleLines() {
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
            document.querySelectorAll('.hint-cell').forEach(cell => {
                cell.classList.remove('hint-possible');
            });
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–æ–∫–∏
            for (let i = 0; i < height; i++) {
                const hints = leftHints[i];
                if (hints.length > 0) {
                    const minFilled = hints.reduce((sum, h) => sum + h, 0) + hints.length - 1;
                    const maxHint = Math.max(...hints);
                    
                    if (minFilled > width / 2 || maxHint > width / 2) {
                        // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —è—á–µ–π–∫–∏ –ø–æ–¥—Å–∫–∞–∑–æ–∫ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏
                        document.querySelectorAll(`input[data-row="${i}"]`).forEach(input => {
                            input.parentElement.classList.add('hint-possible');
                        });
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–±—Ü—ã
            for (let j = 0; j < width; j++) {
                const hints = topHints[j];
                if (hints.length > 0) {
                    const minFilled = hints.reduce((sum, h) => sum + h, 0) + hints.length - 1;
                    const maxHint = Math.max(...hints);
                    
                    if (minFilled > height / 2 || maxHint > height / 2) {
                        // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —è—á–µ–π–∫–∏ –ø–æ–¥—Å–∫–∞–∑–æ–∫ —ç—Ç–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
                        document.querySelectorAll(`input[data-col="${j}"]`).forEach(input => {
                            input.parentElement.classList.add('hint-possible');
                        });
                    }
                }
            }
        }

        function showHints() {
            const changes = findGuaranteedCells();
            
            if (changes.length === 0) {
                showSolverInfo('–ù–µ—Ç –æ—á–µ–≤–∏–¥–Ω—ã—Ö —Ö–æ–¥–æ–≤! –ü–æ–ø—Ä–æ–±—É–π –ª–æ–≥–∏–∫—É üß†', calculateProgress());
                setTimeout(() => hideSolverInfo(), 2000);
                return;
            }
            
            // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ —Ç–∏–ø—É –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è
            const fillCount = changes.filter(c => c.value === 1).length;
            const crossCount = changes.filter(c => c.value === -1).length;
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏
            changes.forEach(change => {
                const cell = document.querySelector(`[data-row="${change.row}"][data-col="${change.col}"]`);
                if (change.value === 1) {
                    cell.classList.add('highlight-guaranteed-fill');
                } else if (change.value === -1) {
                    cell.classList.add('highlight-guaranteed-cross');
                }
            });
            
            let message = `–ù–∞–π–¥–µ–Ω–æ: `;
            if (fillCount > 0) message += `${fillCount} –¥–ª—è –∑–∞–∫—Ä–∞—Å–∫–∏`;
            if (fillCount > 0 && crossCount > 0) message += `, `;
            if (crossCount > 0) message += `${crossCount} –¥–ª—è –∫—Ä–µ—Å—Ç–∏–∫–æ–≤`;
            
            showSolverInfo(message, calculateProgress());
            
            // –£–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
            setTimeout(() => {
                document.querySelectorAll('.highlight-guaranteed-fill, .highlight-guaranteed-cross').forEach(cell => {
                    cell.classList.remove('highlight-guaranteed-fill', 'highlight-guaranteed-cross');
                });
                hideSolverInfo();
            }, 2000);
        }
        
        function solveStep() {
            const changes = findGuaranteedCells();
            
            if (changes.length === 0) {
                showSolverInfo('–ë–æ–ª—å—à–µ –Ω–µ—Ç –æ—á–µ–≤–∏–¥–Ω—ã—Ö —Ö–æ–¥–æ–≤! ü§î', calculateProgress());
                setTimeout(() => hideSolverInfo(), 2000);
                return false;
            }
            
            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É (—Å–Ω–∞—á–∞–ª–∞ —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω—ã –∏ —Å—Ç—Ä–æ–∫–æ–π, –∏ —Å—Ç–æ–ª–±—Ü–æ–º)
            changes.sort((a, b) => {
                // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç–¥–∞–µ–º —Ç–µ–º –∫–ª–µ—Ç–∫–∞–º, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–π–¥–µ–Ω—ã –æ–±–æ–∏–º–∏ —Å–ø–æ—Å–æ–±–∞–º–∏
                const aScore = (a.foundByRow ? 1 : 0) + (a.foundByCol ? 1 : 0);
                const bScore = (b.foundByRow ? 1 : 0) + (b.foundByCol ? 1 : 0);
                return bScore - aScore;
            });
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–µ—Ä–≤–æ–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            const change = changes[0];
            grid[change.row][change.col] = change.value;
            
            const cell = document.querySelector(`[data-row="${change.row}"][data-col="${change.col}"]`);
            if (change.value === 1) {
                cell.classList.add('filled');
                cell.classList.remove('crossed');
                showSolverInfo(`–ó–∞–∫—Ä–∞—à–∏–≤–∞—é –∫–ª–µ—Ç–∫—É [${change.row + 1}, ${change.col + 1}] –ø–æ –ø—Ä–∞–≤–∏–ª—É: ${change.reason}`, calculateProgress());
            } else if (change.value === -1) {
                cell.classList.add('crossed');
                cell.classList.remove('filled');
                showSolverInfo(`–°—Ç–∞–≤–ª—é –∫—Ä–µ—Å—Ç–∏–∫ –≤ [${change.row + 1}, ${change.col + 1}] –ø–æ –ø—Ä–∞–≤–∏–ª—É: ${change.reason}`, calculateProgress());
            }
            
            updateStats();
            
            setTimeout(() => hideSolverInfo(), 3000);
            return true;
        }
        
        function solveFull() {
            let steps = 0;
            let solving = true;
            
            showSolverInfo('–ù–∞—á–∏–Ω–∞—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ... üöÄ', 0);
            
            function solveNextStep() {
                if (!solving) return;
                
                if (solveStep()) {
                    steps++;
                    const progress = calculateProgress();
                    updateProgress(progress);
                    
                    // –î–µ–ª–∞–µ–º –ø–∞—É–∑—É –º–µ–∂–¥—É —à–∞–≥–∞–º–∏ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
                    setTimeout(solveNextStep, 100);
                } else {
                    solving = false;
                    const progress = calculateProgress();
                    
                    if (progress === 100) {
                        showSolverInfo(`–†–µ—à–µ–Ω–æ –∑–∞ ${steps} —à–∞–≥–æ–≤! üéâ`, 100);
                    } else {
                        showSolverInfo(`–°–¥–µ–ª–∞–Ω–æ ${steps} —à–∞–≥–æ–≤. –î–∞–ª—å—à–µ –Ω—É–∂–Ω–∞ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –ª–æ–≥–∏–∫–∞! üß©`, progress);
                    }
                    
                    setTimeout(() => hideSolverInfo(), 3000);
                }
            }
            
            solveNextStep();
        }
        
        function findGuaranteedCells() {
            const changes = [];
            const rowResults = [];
            const colResults = [];
            
            // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏
            for (let i = 0; i < height; i++) {
                const hints = leftHints[i];
                if (hints.length === 0) {
                    // –ï—Å–ª–∏ –Ω–µ—Ç –ø–æ–¥—Å–∫–∞–∑–æ–∫, –≤—Å—è —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫—Ä–µ—Å—Ç–∏–∫–∞–º–∏
                    rowResults[i] = Array(width).fill(-1);
                } else {
                    rowResults[i] = analyzeLine(grid[i], hints, width);
                }
            }
            
            // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã
            for (let j = 0; j < width; j++) {
                const hints = topHints[j];
                const column = [];
                for (let i = 0; i < height; i++) {
                    column.push(grid[i][j]);
                }
                
                if (hints.length === 0) {
                    // –ï—Å–ª–∏ –Ω–µ—Ç –ø–æ–¥—Å–∫–∞–∑–æ–∫, –≤–µ—Å—å —Å—Ç–æ–ª–±–µ—Ü –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫—Ä–µ—Å—Ç–∏–∫–∞–º–∏
                    colResults[j] = Array(height).fill(-1);
                } else {
                    colResults[j] = analyzeLine(column, hints, height);
                }
            }
            
            // –ù–∞—Ö–æ–¥–∏–º –∫–ª–µ—Ç–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã —Å –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    if (grid[i][j] !== 0) continue; // –£–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞
                    
                    const rowValue = rowResults[i] ? rowResults[i][j] : null;
                    const colValue = colResults[j] ? colResults[j][i] : null;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                    if (rowValue !== null && colValue !== null) {
                        if (rowValue === colValue) {
                            // –û–±–∞ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç - —ç—Ç–æ —Ç–æ—á–Ω–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–ª–µ—Ç–∫–∞!
                            changes.push({
                                row: i,
                                col: j,
                                value: rowValue,
                                reason: `–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –∏ —Å—Ç—Ä–æ–∫–æ–π ${i + 1}, –∏ —Å—Ç–æ–ª–±—Ü–æ–º ${j + 1}`,
                                foundByRow: true,
                                foundByCol: true
                            });
                        }
                        // –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∞—Ç –¥—Ä—É–≥ –¥—Ä—É–≥—É, –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
                    } else if (rowValue !== null) {
                        // –¢–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫–∞ –¥–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                        changes.push({
                            row: i,
                            col: j,
                            value: rowValue,
                            reason: `–ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä–æ–∫–∏ ${i + 1}`,
                            foundByRow: true,
                            foundByCol: false
                        });
                    } else if (colValue !== null) {
                        // –¢–æ–ª—å–∫–æ —Å—Ç–æ–ª–±–µ—Ü –¥–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                        changes.push({
                            row: i,
                            col: j,
                            value: colValue,
                            reason: `–ê–Ω–∞–ª–∏–∑ —Å—Ç–æ–ª–±—Ü–∞ ${j + 1}`,
                            foundByRow: false,
                            foundByCol: true
                        });
                    }
                }
            }
            
            // –§–∏–ª—å—Ç—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è, —É–±–∏—Ä–∞–µ–º —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∞—Ç –¥—Ä—É–≥–∏–º –ª–∏–Ω–∏—è–º
            const validChanges = [];
            for (const change of changes) {
                let isValid = true;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—Ç –ª–∏ —ç—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º —Å—Ç–æ–ª–±—Ü–∞
                if (change.foundByRow && !change.foundByCol) {
                    const colHints = topHints[change.col];
                    if (colHints.length === 0 && change.value === 1) {
                        // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–∫—Ä–∞—Å–∏—Ç—å –∫–ª–µ—Ç–∫—É –≤ —Å—Ç–æ–ª–±—Ü–µ –±–µ–∑ –ø–æ–¥—Å–∫–∞–∑–æ–∫
                        isValid = false;
                    } else if (colHints.length > 0) {
                        // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å—Ç–æ–ª–±–µ—Ü —Å —ç—Ç–∏–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º
                        const tempColumn = [];
                        for (let i = 0; i < height; i++) {
                            if (i === change.row) {
                                tempColumn.push(change.value);
                            } else {
                                tempColumn.push(grid[i][change.col]);
                            }
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–æ–∑–º–æ–∂–Ω–æ –ª–∏ —Ç–∞–∫–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
                        const placements = generateValidPlacements(tempColumn, colHints, height);
                        if (placements.length === 0) {
                            isValid = false;
                        }
                    }
                }
                
                // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª—è —Å—Ç–æ–ª–±—Ü–æ–≤
                if (change.foundByCol && !change.foundByRow) {
                    const rowHints = leftHints[change.row];
                    if (rowHints.length === 0 && change.value === 1) {
                        isValid = false;
                    } else if (rowHints.length > 0) {
                        const tempRow = [...grid[change.row]];
                        tempRow[change.col] = change.value;
                        
                        const placements = generateValidPlacements(tempRow, rowHints, width);
                        if (placements.length === 0) {
                            isValid = false;
                        }
                    }
                }
                
                if (isValid) {
                    validChanges.push(change);
                }
            }
            
            return validChanges;
        }
        
        function calculateProgress() {
            let totalHints = 0;
            let satisfiedHints = 0;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–æ–∫–∏
            for (let i = 0; i < height; i++) {
                const hints = leftHints[i];
                if (hints.length > 0) {
                    totalHints++;
                    if (isLineSatisfied(grid[i], hints)) {
                        satisfiedHints++;
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–±—Ü—ã
            for (let j = 0; j < width; j++) {
                const hints = topHints[j];
                if (hints.length > 0) {
                    totalHints++;
                    const column = [];
                    for (let i = 0; i < height; i++) {
                        column.push(grid[i][j]);
                    }
                    if (isLineSatisfied(column, hints)) {
                        satisfiedHints++;
                    }
                }
            }
            
            return totalHints > 0 ? Math.round((satisfiedHints / totalHints) * 100) : 0;
        }
        
        function isLineSatisfied(line, hints) {
            const groups = [];
            let currentGroup = 0;
            
            for (let i = 0; i < line.length; i++) {
                if (line[i] === 1) {
                    currentGroup++;
                } else if (currentGroup > 0) {
                    groups.push(currentGroup);
                    currentGroup = 0;
                }
            }
            if (currentGroup > 0) {
                groups.push(currentGroup);
            }
            
            return JSON.stringify(groups) === JSON.stringify(hints);
        }
        
        function showSolverInfo(message, progress) {
            const info = document.getElementById('solverInfo');
            const messageEl = document.getElementById('solverMessage');
            
            info.style.display = 'block';
            messageEl.textContent = message;
            updateProgress(progress);
        }
        
        function hideSolverInfo() {
            document.getElementById('solverInfo').style.display = 'none';
        }
        
        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function analyzeLine(line, hints, lineLength) {
            if (hints.length === 0) {
                // –ï—Å–ª–∏ –Ω–µ—Ç –ø–æ–¥—Å–∫–∞–∑–æ–∫, –≤—Å–µ –∫–ª–µ—Ç–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∫—Ä–µ—Å—Ç–∏–∫–∞–º–∏
                return Array(lineLength).fill(-1);
            }
            
            const result = Array(lineLength).fill(null);
            
            // 1. Simple Box - –ø–æ–ª–Ω–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
            const minLength = hints.reduce((sum, h) => sum + h, 0) + hints.length - 1;
            if (minLength === lineLength) {
                let pos = 0;
                for (let i = 0; i < hints.length; i++) {
                    if (i > 0) {
                        result[pos++] = -1;
                    }
                    for (let j = 0; j < hints[i]; j++) {
                        result[pos++] = 1;
                    }
                }
                return result;
            }
            
            // 2. –ü—Ä–æ—Å—Ç–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–π –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã
            let currentPos = 0;
            for (let hintIdx = 0; hintIdx < hints.length; hintIdx++) {
                const hintSize = hints[hintIdx];
                
                // –í—ã—á–∏—Å–ª—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–ª–µ–≤–∞
                const spaceLeft = hints.slice(0, hintIdx).reduce((sum, h) => sum + h + 1, 0);
                
                // –í—ã—á–∏—Å–ª—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–ø—Ä–∞–≤–∞
                const spaceRight = hints.slice(hintIdx + 1).reduce((sum, h) => sum + h + 1, 0);
                
                // –ö—Ä–∞–π–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã
                const leftmostStart = spaceLeft;
                const rightmostStart = lineLength - spaceRight - hintSize;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ
                if (leftmostStart <= rightmostStart) {
                    // –ü–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –æ—Ç –∫–æ–Ω—Ü–∞ —Å–∞–º–æ–≥–æ –ø—Ä–∞–≤–æ–≥–æ –Ω–∞—á–∞–ª–∞ –¥–æ –Ω–∞—á–∞–ª–∞ —Å–∞–º–æ–≥–æ –ª–µ–≤–æ–≥–æ –∫–æ–Ω—Ü–∞
                    const overlapStart = rightmostStart;
                    const overlapEnd = leftmostStart + hintSize;
                    
                    // –ó–∞–∫—Ä–∞—à–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–±–ª–∞—Å—Ç—å –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è
                    for (let i = overlapStart; i < overlapEnd && i < lineLength; i++) {
                        if (i >= 0) {
                            result[i] = 1;
                        }
                    }
                }
            }
            
            // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É
            const segments = findFilledSegments(line);
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã, –ø—Ä–æ–±—É–µ–º –∏—Ö —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏
            if (segments.length > 0) {
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—É—é –ª–æ–≥–∏–∫—É —Å —É—á–µ—Ç–æ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–π
                const validPlacements = generateValidPlacements(line, hints, lineLength);
                
                if (validPlacements.length === 0) {
                    // –ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö —Ä–∞–∑–º–µ—â–µ–Ω–∏–π - —á—Ç–æ-—Ç–æ –Ω–µ —Ç–∞–∫
                    return null;
                }
                
                // –ù–∞—Ö–æ–¥–∏–º –æ–±—â–∏–µ –∫–ª–µ—Ç–∫–∏ –≤–æ –≤—Å–µ—Ö –≤–∞–ª–∏–¥–Ω—ã—Ö —Ä–∞–∑–º–µ—â–µ–Ω–∏—è—Ö
                for (let i = 0; i < lineLength; i++) {
                    const firstValue = validPlacements[0][i];
                    if (validPlacements.every(p => p[i] === firstValue)) {
                        result[i] = firstValue;
                    }
                }
            }
            
            // 4. –ü—Ä–∏–º–µ–Ω—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
            applySimpleRules(line, hints, result, lineLength);
            
            return result;
        }
        
        function findFilledSegments(line) {
            const segments = [];
            let start = -1;
            
            for (let i = 0; i < line.length; i++) {
                if (line[i] === 1) {
                    if (start === -1) start = i;
                } else if (start !== -1) {
                    segments.push({ start, end: i - 1, length: i - start });
                    start = -1;
                }
            }
            if (start !== -1) {
                segments.push({ start, end: line.length - 1, length: line.length - start });
            }
            
            return segments;
        }
        
        function applySimpleRules(line, hints, result, lineLength) {
            // –ü—Ä–∞–≤–∏–ª–æ 1: –ï—Å–ª–∏ –µ—Å—Ç—å –∫—Ä–µ—Å—Ç–∏–∫, —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ –æ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —Ç–æ–∂–µ –∫—Ä–µ—Å—Ç–∏–∫–∏
            for (let i = 0; i < lineLength; i++) {
                if (line[i] === 1 || result[i] === 1) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–µ–π
                    if (i > 0 && (line[i-1] === -1 || result[i-1] === -1)) {
                        // –°–ª–µ–≤–∞ –∫—Ä–µ—Å—Ç–∏–∫, –∑–Ω–∞—á–∏—Ç —ç—Ç–æ –Ω–∞—á–∞–ª–æ –≥—Ä—É–ø–ø—ã
                        let groupEnd = i;
                        while (groupEnd < lineLength && (line[groupEnd] === 1 || result[groupEnd] === 1)) {
                            groupEnd++;
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç –ª–∏ —ç—Ç–∞ –≥—Ä—É–ø–ø–∞ —Ä–∞—Å—à–∏—Ä–∏—Ç—å—Å—è
                        const groupLength = groupEnd - i;
                        const canExtend = hints.some(h => h > groupLength);
                        
                        if (!canExtend && groupEnd < lineLength) {
                            result[groupEnd] = -1;
                        }
                    }
                }
            }
            
            // –ü—Ä–∞–≤–∏–ª–æ 2: –ü—Ä–æ–º–µ–∂—É—Ç–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —Å–ª–∏—à–∫–æ–º –º–∞–ª—ã –¥–ª—è –ª—é–±–æ–π –ø–æ–¥—Å–∫–∞–∑–∫–∏
            const minHint = Math.min(...hints);
            let gapStart = -1;
            
            for (let i = 0; i <= lineLength; i++) {
                const isCross = i === lineLength || line[i] === -1 || result[i] === -1;
                
                if (isCross) {
                    if (gapStart !== -1) {
                        const gapSize = i - gapStart;
                        if (gapSize < minHint) {
                            // –ó–∞–ø–æ–ª–Ω—è–µ–º –≤–µ—Å—å –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ –∫—Ä–µ—Å—Ç–∏–∫–∞–º–∏
                            for (let j = gapStart; j < i; j++) {
                                if (line[j] === 0) {
                                    result[j] = -1;
                                }
                            }
                        }
                    }
                    gapStart = i + 1;
                } else if (line[i] === 1 || result[i] === 1) {
                    gapStart = -1;
                }
            }
            
            // –ü—Ä–∞–≤–∏–ª–æ 3: –ï—Å–ª–∏ –≤—Å–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ "–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã"
            const filledGroups = [];
            let inGroup = false;
            let groupSize = 0;
            
            for (let i = 0; i < lineLength; i++) {
                if (line[i] === 1) {
                    if (!inGroup) {
                        inGroup = true;
                        groupSize = 1;
                    } else {
                        groupSize++;
                    }
                } else if (inGroup) {
                    filledGroups.push(groupSize);
                    inGroup = false;
                    groupSize = 0;
                }
            }
            if (inGroup) {
                filledGroups.push(groupSize);
            }
            
            // –ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥—Ä—É–ø–ø —Ä–∞–≤–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –ø–æ–¥—Å–∫–∞–∑–æ–∫
            if (filledGroups.length === hints.length) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞—é—Ç –ª–∏ —Ä–∞–∑–º–µ—Ä—ã
                let allMatch = true;
                for (let i = 0; i < hints.length; i++) {
                    if (filledGroups[i] !== hints[i]) {
                        allMatch = false;
                        break;
                    }
                }
                
                if (allMatch) {
                    // –í—Å–µ –≥—Ä—É–ø–ø—ã –Ω–∞–π–¥–µ–Ω—ã, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ - –∫—Ä–µ—Å—Ç–∏–∫–∏
                    for (let i = 0; i < lineLength; i++) {
                        if (line[i] === 0 && result[i] === null) {
                            result[i] = -1;
                        }
                    }
                }
            }
        }
        
        function generateValidPlacements(line, hints, lineLength) {
            const placements = [];
            
            function generate(hintIndex, position, current) {
                if (hintIndex === hints.length) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –ø–æ–∑–∏—Ü–∏–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º–∏
                    const placement = [...current];
                    for (let i = position; i < lineLength; i++) {
                        if (line[i] === 1) return; // –ö–æ–Ω—Ñ–ª–∏–∫—Ç - –µ—Å—Ç—å –∑–∞–∫—Ä–∞—à–µ–Ω–Ω–∞—è –∫–ª–µ—Ç–∫–∞ –≤–Ω–µ –≥—Ä—É–ø–ø
                        placement[i] = -1;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–ª–µ—Ç–∫–∞–º
                    for (let i = 0; i < lineLength; i++) {
                        if (line[i] !== 0 && line[i] !== placement[i]) return;
                    }
                    
                    placements.push(placement);
                    return;
                }
                
                const hintSize = hints[hintIndex];
                const remainingHints = hints.slice(hintIndex + 1);
                const minRemainingSpace = remainingHints.reduce((sum, h) => sum + h + 1, 0);
                const maxPosition = lineLength - hintSize - minRemainingSpace;
                
                for (let start = position; start <= maxPosition; start++) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –≥—Ä—É–ø–ø—É –∑–¥–µ—Å—å
                    let canPlace = true;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫—Ä–µ—Å—Ç–∏–∫–∏ –≤ –≥—Ä—É–ø–ø–µ
                    for (let i = start; i < start + hintSize; i++) {
                        if (line[i] === -1) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é –∫–ª–µ—Ç–∫—É –ø–µ—Ä–µ–¥ –≥—Ä—É–ø–ø–æ–π
                    if (start > 0 && line[start - 1] === 1) canPlace = false;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é –∫–ª–µ—Ç–∫—É –ø–æ—Å–ª–µ –≥—Ä—É–ø–ø—ã
                    if (start + hintSize < lineLength && line[start + hintSize] === 1) canPlace = false;
                    
                    if (!canPlace) continue;
                    
                    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
                    const newPlacement = [...current];
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–µ—Å—Ç–∏–∫–∏ –ø–µ—Ä–µ–¥ –≥—Ä—É–ø–ø–æ–π
                    for (let i = position; i < start; i++) {
                        newPlacement[i] = -1;
                    }
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä—É–ø–ø—É
                    for (let i = start; i < start + hintSize; i++) {
                        newPlacement[i] = 1;
                    }
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–µ—Å—Ç–∏–∫ –ø–æ—Å–ª–µ –≥—Ä—É–ø–ø—ã (–µ—Å–ª–∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω—è—è)
                    if (hintIndex < hints.length - 1 && start + hintSize < lineLength) {
                        newPlacement[start + hintSize] = -1;
                        generate(hintIndex + 1, start + hintSize + 1, newPlacement);
                    } else {
                        generate(hintIndex + 1, start + hintSize, newPlacement);
                    }
                }
            }
            
            generate(0, 0, Array(lineLength).fill(0));
            return placements;
        }

        function clearGrid() {
            grid = Array(height).fill().map(() => Array(width).fill(0));
            document.querySelectorAll('.game-cell').forEach(cell => {
                cell.classList.remove('filled', 'crossed');
                cell.style.background = '';
            });
            updateStats();
        }

        function updateStats() {
            let filled = 0;
            let crossed = 0;
            
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    if (grid[i][j] === 1) filled++;
                    if (grid[i][j] === -1) crossed++;
                }
            }
            
            document.getElementById('statsInfo').innerHTML = 
                `–ó–∞–∫—Ä–∞—à–µ–Ω–æ: ${filled} | –ö—Ä–µ—Å—Ç–∏–∫–æ–≤: ${crossed} | –í—Å–µ–≥–æ –∫–ª–µ—Ç–æ–∫: ${width * height}`;
        }

        // –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–∂–∞—Ç–∏–π –∫–ª–∞–≤–∏—à –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
        function handleHintKeyDown(e) {
            if (!currentFocusedInput) return;
            
            const isTopHint = currentFocusedInput.dataset.col !== undefined;
            const isLeftHint = currentFocusedInput.dataset.row !== undefined;
            
            let nextInput = null;
            
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (isTopHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö –ø–æ —Å—Ç–æ–ª–±—Ü—É –ø–æ–¥—Å–∫–∞–∑–æ–∫
                    const col = parseInt(currentFocusedInput.dataset.col);
                    const hintRow = parseInt(currentFocusedInput.dataset.hintRow);
                    if (hintRow > 0) {
                        nextInput = document.querySelector(`input[data-col="${col}"][data-hint-row="${hintRow - 1}"]`);
                    }
                } else if (isLeftHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö –ø–æ –ª–µ–≤—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
                    const row = parseInt(currentFocusedInput.dataset.row);
                    const hintCol = parseInt(currentFocusedInput.dataset.hintCol);
                    if (row > 0) {
                        nextInput = document.querySelector(`input[data-row="${row - 1}"][data-hint-col="${hintCol}"]`);
                    }
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (isTopHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–Ω–∏–∑ –ø–æ —Å—Ç–æ–ª–±—Ü—É –ø–æ–¥—Å–∫–∞–∑–æ–∫
                    const col = parseInt(currentFocusedInput.dataset.col);
                    const hintRow = parseInt(currentFocusedInput.dataset.hintRow);
                    const maxTopHints = Math.ceil(height / 2);
                    if (hintRow < maxTopHints - 1) {
                        nextInput = document.querySelector(`input[data-col="${col}"][data-hint-row="${hintRow + 1}"]`);
                    }
                } else if (isLeftHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–Ω–∏–∑ –ø–æ –ª–µ–≤—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
                    const row = parseInt(currentFocusedInput.dataset.row);
                    const hintCol = parseInt(currentFocusedInput.dataset.hintCol);
                    if (row < height - 1) {
                        nextInput = document.querySelector(`input[data-row="${row + 1}"][data-hint-col="${hintCol}"]`);
                    }
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (isTopHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ –ø–æ –≤–µ—Ä—Ö–Ω–∏–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
                    const col = parseInt(currentFocusedInput.dataset.col);
                    const hintRow = parseInt(currentFocusedInput.dataset.hintRow);
                    if (col > 0) {
                        nextInput = document.querySelector(`input[data-col="${col - 1}"][data-hint-row="${hintRow}"]`);
                    }
                } else if (isLeftHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ –ø–æ –ª–µ–≤—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
                    const row = parseInt(currentFocusedInput.dataset.row);
                    const hintCol = parseInt(currentFocusedInput.dataset.hintCol);
                    if (hintCol > 0) {
                        nextInput = document.querySelector(`input[data-row="${row}"][data-hint-col="${hintCol - 1}"]`);
                    }
                }
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (isTopHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –ø–æ –≤–µ—Ä—Ö–Ω–∏–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
                    const col = parseInt(currentFocusedInput.dataset.col);
                    const hintRow = parseInt(currentFocusedInput.dataset.hintRow);
                    if (col < width - 1) {
                        nextInput = document.querySelector(`input[data-col="${col + 1}"][data-hint-row="${hintRow}"]`);
                    }
                } else if (isLeftHint) {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –ø–æ –ª–µ–≤—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º
                    const row = parseInt(currentFocusedInput.dataset.row);
                    const hintCol = parseInt(currentFocusedInput.dataset.hintCol);
                    const maxLeftHints = Math.ceil(width / 2);
                    if (hintCol < maxLeftHints - 1) {
                        nextInput = document.querySelector(`input[data-row="${row}"][data-hint-col="${hintCol + 1}"]`);
                    }
                }
            }
            
            if (nextInput) {
                nextInput.focus();
                currentFocusedInput = nextInput;
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        createGrid();
    </script>
</body>
</html>
